package mavery.projecteuler;

public class Problem101
{
	public static final int LIMIT = 10;

	/**
	 * If we are presented with the first k terms of a sequence it is impossible
	 * to say with certainty the value of the next term, as there are infinitely
	 * many polynomial functions that can model the sequence.
	 * 
	 * As an example, let us consider the sequence of cube numbers. This is
	 * defined by the generating function, un = n3: 1, 8, 27, 64, 125, 216, ...
	 * 
	 * Suppose we were only given the first two terms of this sequence. Working
	 * on the principle that "simple is best" we should assume a linear
	 * relationship and predict the next term to be 15 (common difference 7).
	 * Even if we were presented with the first three terms, by the same
	 * principle of simplicity, a quadratic relationship should be assumed.
	 * 
	 * We shall define OP(k, n) to be the nth term of the optimum polynomial
	 * generating function for the first k terms of a sequence. It should be
	 * clear that OP(k, n) will accurately generate the terms of the sequence
	 * for n k, and potentially the first incorrect term (FIT) will be OP(k,
	 * k+1); in which case we shall call it a bad OP (BOP).
	 * 
	 * As a basis, if we were only given the first term of sequence, it would be
	 * most sensible to assume constancy; that is, for n 2, OP(1, n) = u1.
	 * 
	 * Hence we obtain the following OPs for the cubic sequence:OP(1, n) = 1 1,
	 * 1, 1, 1, ... OP(2, n) = 7n6 1, 8, 15, ... OP(3, n) = 6n211n+6 1, 8, 27,
	 * 58, ... OP(4, n) = n3 1, 8, 27, 64, 125, ...
	 * 
	 * 
	 * Clearly no BOPs exist for k >= 4.
	 * 
	 * By considering the sum of FITs generated by the BOPs (indicated in red
	 * above), we obtain 1 + 15 + 58 = 74.
	 * 
	 * Consider the following tenth degree polynomial generating function:
	 * 
	 * u(n) = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 + n^10
	 * 
	 * Find the sum of FITs for the BOPs.
	 */
	public static void main(String[] args)
	{
		long result = 0;

		for (int i = 1; i <= 10; i++)
		{
			result += bop(i);
		}
		System.out.println(result);
	}

	/**
	 * Returns the first incorrect term for the optimal polynomial function of
	 * u(x) generated from the first n terms of u(x)
	 * 
	 * @param n
	 *            The number of terms to use to generate the polynomial function
	 * @return The first term of the polynomial function that does not match
	 *         u(x)
	 */
	public static long bop(int n)
	{
		for (int i = 1; /* no test */; i++)
		{
			long current = op(i, n);
			if (u(i) != current)
			{
				return current;
			}
		}
	}

	/**
	 * Calculates the value of the optimal polynomial function generated by the
	 * first n terms of u(n). Uses the general formula for the Lagrange
	 * Interpolating Polynomial.
	 * 
	 * @param x
	 *            input to the function
	 * @param n
	 *            The number of terms to use to generate the polynomial.
	 * @return F(x) where F is the optimal polynomial function generated by the
	 *         first n terms of u(n)
	 * 
	 * @see <a
	 *      href="http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html">Formula
	 *      for the Lagrange Interpolating Polynomial</a>
	 */
	public static long op(int x, int n)
	{
		long result = 0;
		for (int j = 1; j <= n; j++)
		{
			long current = u(j);

			// perform the multiplications first to avoid any issues with
			// rounding.
			for (int k = 1; k <= n; k++)
			{
				if (j == k)
				{
					continue;
				}
				current *= (x - k);
			}
			for (int k = 1; k <= n; k++)
			{
				if (j == k)
				{
					continue;
				}
				current /= (j - k);
			}
			result += current;
		}

		return result;
	}

	/**
	 * The function u(n) as defined in the problem.
	 * 
	 * @param n
	 *            The parameter to the function
	 * @return u(n) = 1 - n + n^2 - n^3 + n^4 - n^5 + n^6 - n^7 + n^8 - n^9 +
	 *         n^10
	 */
	public static long u(int n)
	{
		long result = 0;
		long current = 1;
		for (int i = 0; i <= 10; i++)
		{
			if (i % 2 == 0)
			{
				result += current;
			}
			else
			{
				result -= current;
			}
			current *= n;
		}

		return result;
	}
}
